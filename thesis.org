* Imaginary programming is a new programming paradigm based on language models

** Main idea
Imaginary code is code who's behaviour is influenced by language models. I will
attempt to formalise imaginary programming, make some demonstrations of
programming within this paradigm and explore some useful data structures and
algorithms that are both impurely and purely imaginary. The motivation for
formalising this is not purely academic. Imaginary code needs to
be recognised as code so that it may be protected by GPL. I also posit that
models of natural language, if trained on source code, create a holographic
representation of the software, which I argue is a derivative work and a
reflection of the original code. I argue that a holographic representation of
software both within (author inspiration) and without (how it is used) is just another
representation of the software, alongside the original source code, just as
functions may be represented differently. In the future, as holographic
software is used more, and language models are used more to simulate software,
the hologram of the software may be used for reasons that the original author
expressly forbid and mixing data with different licenses effectively relicences
the same software.

** Supporting idea - impure imaginary code
The recently burgeoning and soon to diminish
programming paradigm of prompt engineering is
about to be superseded by prompt-tuning and
the fine-tuning of LMs which will further
occlude the way that software works. Prompt
engineering has barely had it's time in the
spotlight and as a result has not established
itself as a sovereign programming paradigm.

However, imaginary programming is a broader
definition that encapsulates all programming
that solicits LMs and uses their output to
affect a program's logic and will outlast
prompt engineering as a useful concept.

In contrast with imaginary code, ordinary code
has not yet been contaminated by a LM, and we
say that it has no imaginary dimension to it.

Impure imaginary code is where ordinary code
intersects with pure imaginary code. An impure
imaginary function is a function that queries
a LM to directly affect its own logic or
output. We say that an impure imaginary
function is grounded [to reality] because it's
connecting base reality to a LM.

The output and behaviour of an impure
imaginary function is directly influenced by
base reality plus a query to a LM.

The query [or prompt] to the LM may be in part
constructed manually through prompt
engineering, or in part constructed
automatically via prompt tuning, or in part 
constructed or eliminated by the fine-tuning of a LM.
Even after fine-tuning, there
is still a query to be formulated to the LM,
and that query may indeed be the empty string.

Considering that large LMs such as GPT-3
can perform multiple tasks, the process of
refining a query through prompt-engineering,
prompt-tuning or fine-tuning also
characterises the expected output from the LM.
All that is left is to map a prompt along with
its associated LM to a function and then you
have a prompt function.

Prompt functions reconcile LMs with
programming languages and to be clear, a
prompt function is a function that queries a
LM with a prompt.

Such functions are the basis for services such
as GitHub Copilot.

I demonstate that impure imaginary programming
is useful for constructing an imaginary
programming environment, performing code generation, transpiling, code
understanding and NLP.

** Supporting idea - pure imaginary code
Pure imaginary programming is a type of programming where the original language
models may not even be known.

I demonstate that collaborative pure imaginary programming is useful.

** Supporting idea - language models encode holographic representations of software
I am able to generate parts of GPL protected software using language models and
can query the language models as to how they are used.

Therefore, the software exists now in the latent space of a language model in
the form of a hologram, within and without the source code. Language models
encode contrived associations made between different pieces of software in
order to create an accurate model that is useful for simulation, code
generation, code understanding and modelling the usage of software.

** Include an opposing viewpoint to your main idea, if applicable