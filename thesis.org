* Imaginary programming is a new programming paradigm based on language models

** Main idea
Imaginary code is code who's behaviour is influenced by language models. I will
attempt to formalise imaginary programming, make some demonstrations of
programming within this paradigm and explore some useful data structures and
algorithms that are both impurely and purely imaginary. The motivation for
formalising this is not purely academic. Imaginary code needs to
be recognised as code so that it may be protected by GPL. I also posit that
models of natural language, if trained on source code, create a holographic
representation of the software, which I argue is a derivative work and a
reflection of the original code. I argue that a holographic representation of
software both within (author inspiration) and without (how it is used) is just another
representation of the software, alongside the original source code, just as
functions may be represented differently. In the future, as holographic
software is used more, and language models are used more to simulate software,
the hologram of the software may be used for reasons that the original author
expressly forbid and mixing data with different licenses effectively relicences
the same software.

** Supporting idea - impure imaginary code
The recently burgeoning and soon to diminish
programming paradigm of prompt engineering is
about to be superseded by prompt-tuning and
the fine-tuning of LMs which will further
occlude the way that software works. Prompt
engineering has barely had it's time in the
spotlight and as a result has not established
itself as a sovereign programming paradigm.

However, imaginary programming is a broader
definition that encapsulates all programming
that solicits LMs and uses their output to
affect a program's logic and will outlast
prompt engineering as a useful concept.

In contrast with imaginary code, ordinary code
has not yet been contaminated by a LM, and we
say that it has no imaginary dimension to it.

Impure imaginary code is where ordinary code
intersects with pure imaginary code. An impure
imaginary function is a function that queries
a LM to directly affect its own logic or
output. We say that an impure imaginary
function is grounded [to reality] because it's
connecting base reality to a LM.

The output and behaviour of an impure
imaginary function is directly influenced by
base reality plus a query to a LM.

The query [or prompt] to the LM may be in part
constructed manually through prompt
engineering, or in part constructed
automatically via prompt tuning, or in part 
constructed or eliminated by the fine-tuning of a LM.
Even after fine-tuning, there
is still a query to be formulated to the LM,
and that query may indeed be the empty string.

Considering that large LMs such as GPT-3
can perform multiple tasks, the process of
refining a query through prompt-engineering,
prompt-tuning or fine-tuning also
characterises the expected output from the LM.
All that is left is to map a prompt along with
its associated LM to a function and then you
have a prompt function.

Prompt functions reconcile LMs with
programming languages and to be clear, a
prompt function is a function that queries a
LM with a prompt.

Such functions are the basis for services such
as GitHub Copilot.

I demonstate that impure imaginary programming
is useful for constructing an imaginary
programming environment, performing code generation, transpiling, code
understanding and NLP.

The following prompt function definition function
associates a prompt with a LM (OpenAI's GPT-3
davinci) and defines the parameters for a function in emacs lisp.

#+BEGIN_SRC yaml -n :async :results verbatim code
  title: bash one liner generator on OS from natural language
  doc: Get a bash one liner on OS from natural language
  notes:
  - "rlprompt is used here outside of pen.el"
  rlprompt: nlsh <1>
  prompt: |
      # List of one-liner shell commands for <1>.
      # Language: Shell
      # Operating System: <1>

      Input: Print the current directory
      Output: pwd
      ###
      Input: List files
      Output: ls -l
      ###
      Input: Change directory to /tmp
      Output: cd /tmp
      ###
      repeater: |
      Input: {}
      Output:
  lm-command: "openai-complete.sh"
  engine: davinci
  temperature: 0.8
  max-tokens: 60
  top-p: 1
  stop-sequences:
  - "###"
  vars:
  - Operating System
  - command
  examples:
  - Arch Linux
  - Install package
  postprocessor: 'sed ''s/^Output: //'''
  conversation-mode: true
#+END_SRC

The following is the generated documentation
and function in emacs lisp.

#+BEGIN_SRC text -n :async :results verbatim code
  pf-bash-one-liner-generator-from-natural-language is an interactive
  function defined in pen-example-config.el.

  Signature
  (pf-bash-one-liner-generator-from-natural-language &optional TASK-DESCRIPTION &key NO-SELECT-RESULT)

  Documentation
  bash one liner generator from natural language
  Get a bash one liner from natural language

  path:
  - /home/shane/source/git/spacemacs/prompts/prompts/bash-one-liner.prompt

  examples:
  - shift last argument

  Key Bindings
  This command is not in any keymaps.

  References
  pf-bash-one-liner-generator-from-natural-language is unused in pen-example-config.el.

  Find all references Functions used by pf-bash-one-liner-generator-from-natural-language

  Debugging
  Enable tracing
  Disassemble Forget

  Source Code
  ;; Defined in ~/source/git/semiosis/pen.el/src/pen-example-config.el
  ;; Could not find source code, showing raw function object.

  Symbol Properties
  event-symbol-element-mask
    (pf-bash-one-liner-generator-from-natural-language 0)
  event-symbol-elements
    (pf-bash-one-liner-generator-from-natural-language)
  modifier-cache
    ((0 . pf-bash-one-liner-generator-from-natural-language))
#+END_SRC

#+BEGIN_SRC emacs-lisp -n :async :results verbatim code
  (lambda
    (&optional task-description &rest --cl-rest--)
    "bash one liner generator from natural language\nGet a bash one liner from natural language\n\npath:\n- /home/shane/source/git/spacemacs/prompts/prompts/bash-one-liner.prompt\n\nexamples:\n- shift last argument\n\n(fn &optional TASK-DESCRIPTION &key NO-SELECT-RESULT)"
    (interactive
     (list
      (if mark-active
          (pen-selected-text)
        (if nil
            (etv "shift last argument")
          (read-string-hist "task-description: " "shift last argument")))))
    (let*
        ((no-select-result
          (car
           (cdr
            (plist-member --cl-rest-- ':no-select-result)))))
      (progn
        (let
            ((--cl-keys-- --cl-rest--))
          (while --cl-keys--
            (cond
             ((memq
               (car --cl-keys--)
               '(:no-select-result :allow-other-keys))
              (setq --cl-keys--
                    (cdr
                     (cdr --cl-keys--))))
             ((car
               (cdr
                (memq ':allow-other-keys --cl-rest--)))
              (setq --cl-keys-- nil))
             (t
              (error "Keyword argument %s not one of (:no-select-result)"
                     (car --cl-keys--))))))
        (cl-block pf-bash-one-liner-generator-from-natural-language
          (let*
              ((final-prompt "The following is a list of one-liners for the linux command-line:\n\n# get newest file in directory bash\n$ ls -t * | head -1\n###\n# Find with invert match - e.g. find every file that is not mp3\n$ find . -name '*' -type f -not -path '*.mp3'\n###\n# Recursively remove all \"node_modules\" folders\n$ find . -name \"node_modules\" -exec rm -rf '{}' +\n###\n# <1>\n$\n")
               (final-max-tokens
                (str
                 (if
                     (variable-p 'max-tokens)
                     (eval 'max-tokens)
                   60)))
               (final-stop-sequences
                (if
                    (variable-p 'stop-sequences)
                    (eval 'stop-sequences)
                  '("###")))
               (vals
                (mapcar 'str
                        (if
                            (not
                             (interactive-p))
                            (progn
                              (cl-loop for sym in
                                       '(task-description)
                                       for iarg in
                                       '((if mark-active
                                             (pen-selected-text)
                                           (if nil
                                               (etv "shift last argument")
                                             (read-string-hist "task-description: " "shift last argument"))))
                                       collect
                                       (let*
                                           ((initval
                                             (eval sym)))
                                         (if
                                             (and
                                              (not initval)
                                              iarg)
                                             (eval iarg)
                                           initval))))
                          (cl-loop for v in
                                   '(task-description)
                                   until
                                   (eq v '&key)
                                   collect
                                   (eval v)))))
               (vals
                (cl-loop for tp in
                         (-zip-fill nil vals 'nil)
                         collect
                         (let*
                             ((v
                               (car tp))
                              (pp
                               (cdr tp)))
                           (if pp
                               (pen-sn pp v)
                             v))))
               (i 1)
               (final-prompt
                (pen-expand-template final-prompt vals))
               (prompt-end-pos
                (or
                 (byte-string-search "<:pp>" "The following is a list of one-liners for the linux command-line:\n\n# get newest file in directory bash\n$ ls -t * | head -1\n###\n# Find with invert match - e.g. find every file that is not mp3\n$ find . -name '*' -type f -not -path '*.mp3'\n###\n# Recursively remove all \"node_modules\" folders\n$ find . -name \"node_modules\" -exec rm -rf '{}' +\n###\n# <1>\n$\n")
                 (string-bytes final-prompt)))
               (final-prompt
                (string-replace "<:pp>" "" final-prompt))
               (final-prompt
                (if nil
                    (sor
                     (pen-snc nil final-prompt)
                     (concat "prompt-filter " nil " failed."))
                  final-prompt))
               (pen-sh-update
                (or pen-sh-update
                    (>=
                     (prefix-numeric-value current-global-prefix-arg)
                     4)))
               (shcmd
                (pen-log
                 (concat
                  (sh-construct-envs
                   `(("PEN_PROMPT" ,(pen-encode-string final-prompt))
                     ("PEN_LM_COMMAND" ,"openai-complete.sh")
                     ("PEN_ENGINE" ,"davinci")
                     ("PEN_MAX_TOKENS" ,(pen-expand-template final-max-tokens vals))
                     ("PEN_TEMPERATURE" ,(pen-expand-template
                                          (str 0.8)
                                          vals))
                     ("PEN_STOP_SEQUENCE" ,(pen-encode-string
                                            (str
                                             (if
                                                 (variable-p 'stop-sequence)
                                                 (eval 'stop-sequence)
                                               "###"))))
                     ("PEN_TOP_P" ,1)
                     ("PEN_CACHE" ,nil)
                     ("PEN_N_COMPLETIONS" ,5)
                     ("PEN_END_POS" ,prompt-end-pos)))
                  " " "upd lm-complete")))
               (resultsdirs
                (cl-loop for i in
                         (number-sequence 1 1)
                         collect
                         (progn
                           (message
                            (concat "pf-bash-one-liner-generator-from-natural-language" " query "
                                    (int-to-string i)
                                    "..."))
                           (let
                               ((ret
                                 (pen-prompt-snc shcmd i)))
                             (message
                              (concat "pf-bash-one-liner-generator-from-natural-language" " done "
                                      (int-to-string i)))
                             ret))))
               (results
                (-uniq
                 (flatten-once
                  (cl-loop for rd in resultsdirs collect
                           (if
                               (sor rd)
                               (->>
                                   (glob
                                    (concat rd "/*"))
                                 (mapcar 'e/cat)
                                 (mapcar
                                  (lambda
                                    (r)
                                    (if
                                        (and nil
                                             (sor nil))
                                        (pen-sn nil r)
                                      r)))
                                 (mapcar
                                  (lambda
                                    (r)
                                    (if
                                        (and
                                         (variable-p 'prettify)
                                         prettify nil
                                         (sor nil))
                                        (pen-sn nil r)
                                      r)))
                                 (mapcar
                                  (lambda
                                    (r)
                                    (if
                                        (not nil)
                                        (s-trim-left r)
                                      r)))
                                 (mapcar
                                  (lambda
                                    (r)
                                    (if
                                        (not nil)
                                        (s-trim-right r)
                                      r)))
                                 (mapcar
                                  (lambda
                                    (r)
                                    (cl-loop for stsq in final-stop-sequences do
                                             (let
                                                 ((matchpos
                                                   (string-search stsq r)))
                                               (if matchpos
                                                   (setq r
                                                         (s-truncate matchpos r "")))))
                                    r)))
                             (list
                              (message "Try UPDATE=y or debugging")))))))
               (result
                (if no-select-result
                    (length results)
                  (cl-fz results :prompt
                         (concat "pf-bash-one-liner-generator-from-natural-language" ": ")
                         :select-only-match t))))
            (if no-select-result results
              (if
                  (interactive-p)
                  (cond
                   ((>=
                     (prefix-numeric-value current-prefix-arg)
                     4)
                    (etv result))
                   ((and nil mark-active)
                    (replace-region result))
                   ((or nil nil)
                    (insert result))
                   (t
                    (etv result)))
                result)))))))
#+END_SRC

** Supporting idea - pure imaginary code
Pure imaginary programming is a type of programming where the original language
models may not even be known.

I demonstate that collaborative pure imaginary programming is useful.

** Supporting idea - language models encode holographic representations of software
I am able to generate parts of GPL protected software using language models and
can query the language models as to how they are used.

Therefore, the software exists now in the latent space of a language model in
the form of a hologram, within and without the source code. Language models
encode contrived associations made between different pieces of software in
order to create an accurate model that is useful for simulation, code
generation, code understanding and modelling the usage of software.

** Include an opposing viewpoint to your main idea, if applicable