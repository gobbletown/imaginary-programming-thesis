* Imaginary programming is a new programming paradigm based on language models

** Main idea
Imaginary code is code who's behaviour is influenced by language models. I will
attempt to formalise imaginary programming, make some demonstrations of
programming within this paradigm and explore some useful data structures and
algorithms that are both impurely and purely imaginary. The motivation for
formalising this is not purely academic. Imaginary code needs to
be recognised as code so that it may be protected by GPL. I also posit that
models of natural language, if trained on source code, create a holographic
representation of the software, which I argue is a derivative work and a
reflection of the original code. I argue that a holographic representation of
software both within (author inspiration) and without (how it is used) is just another
representation of the software, alongside the original source code, just as
functions may be represented differently. In the future, as holographic
software is used more, and language models are used more to simulate software,
the hologram of the software may be used for reasons that the original author
expressly forbid and mixing data with different licenses effectively relicences
the same software.

** Supporting idea - impure imaginary code
The recently burgeoning and soon to be
diminishing programming paradigm of prompt
engineering is about to be superseded by
prompt-tuning and the fine-tuning of LMs which
will further occlude the way that software
works. Prompt engineering barely had it's time
in the spotlight and as a result has not
established itself as a sovereign programming
paradigm.

However, imaginary programming is a broader
definition that encapsulates all programming
that solicits LMs and uses their output to
affect a program's logic.

In contrast with imaginary code, ordinary code
has not yet been contaminated by a LM, and we
say that it has no imaginary dimension to it.

Impure imaginary code is where ordinary code
intersects with pure imaginary code. An impure
imaginary function is a function that queries
a LM to directly affect its own logic or
output. We say that an impure imaginary
function is grounded [to reality] because it's
connecting base reality to a LM.

The output of an impure
imaginary function is directly influenced by a
query to a LM.

Those prompts may
be designed in a process that is called prompt
engineering, or they may be the result of an
optimisation process called prompt-tuning.
A prompt function is a function that queries a language model with a prompt.

Such functions are the basis for services such as GitHub Copilot. Prompt-tuning still imaginary programming.

I demonstate that prompt engineering is useful for constructing an imaginary
programming environment, code generation, code understanding and natural
language processing.

** Supporting idea - pure imaginary code
Pure imaginary programming is a type of programming where the original language
models may not even be known.

I demonstate that collaborative pure imaginary programming is useful.

** Supporting idea - language models encode holographic representations of software
I am able to generate parts of GPL protected software using language models and
can query the language models as to how they are used.

Therefore, the software exists now in the latent space of a language model in
the form of a hologram, within and without the source code. Language models
encode contrived associations made between different pieces of software in
order to create an accurate model that is useful for simulation, code
generation, code understanding and modelling the usage of software.

** Include an opposing viewpoint to your main idea, if applicable